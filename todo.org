

We want to add a feature to the DPM project where you can save documents and document fragments, which we'll just call notes.
Both the notes and the full documents should be storable in various formats, text, org, markdown, and PDF.
Any notes that are created should be collected into a unfiled document, a document called unfiled.

So, the note structure should have an optional title. And if the title
is not present, it should default, property for the title should
default to the first eight words of the note.  So, whenever notes are
included in a document, which is always all notes must be included in
a document, the document will have a line that is the title of the
note.

The UI will make it possible to link through to the individual
notes or show them intact and in whole. This will only work if all the
notes document are the same format. We don't want to get into the
complexity of converting formats live.  So, all of the primary models
are DPM project, task, all those should, I don't remember if there are
any others, but they should each be able to be associated with any
number of notes and documents. So, I guess this is probably just a
foreign key relationship from the note model and the document model
back to whatever they're attached to.



We also want to be able to define special taxonomies. Creating them
doesn't need to have any UI support, because there will be a small
number that live long term. So, they can probably be loaded from a
config file, synced with the database from a config file.

These taxonomies will relate to the main models. So, for example, you
can have a top-level category that always refers to a project or a
domain even. And underneath it, the individual elements of the
taxonomy can refer to sub-projects or tasks. So, essentially, it
defines a specific area in which the normal taxonomy gets laid out.

One example of this would be the categorization taxonomy for software
projects.

So, at the top, you have vision. The vision is probably a
domain, and it would never have any tasks, even if it's a project.

The next level below that would be a deliverable. A deliverable would
be a project. It would never be a task.

The next level below, a deliverable would be an epic. Now, an epic is
a project, and it will probably have sub-projects. For simplicity it
is not allowed to have tasks directly connected, they can only be connected
to stories. 

The next level is a story. So, a story is... In the database, a story
is a... It's a project. It isn't a task. So, an epic is made up of
some number of stories and possible direct tasks, sub-projects, and
database tasks.

The next level is a software engineering-style task, which is not
necessarily... It's not conceptually exactly the same thing as a DPM
task, but it's a one-to-one relationship.

So, tasks always exist as either a direct child of an epic or a direct
child of a story in this particular categorization mechanism.

So, from all of the above, these taxonomies are a tree structure, and
at each level, they can refer to exactly one of the levels in the
DPM. So, you have the possibility of a domain, a project, and a task.

At creation time for taxonomy elements they create a link primary
model, domain, project, or task. The taxonomy level definition
(branch, leaf?)  defines the primary dpm model it overlays, and the
taxonomy model instance has a reference to the instance of that dpm
model that it creates. 

#+begin_src python
  from enum import StrEnum, auto
  from typing import Optional

  class DPMBase(StrEnum):
      domain = auto()
      project = auto()
      task = auto()

  class TaxoDef:
      """ Used to define a taxonomy"""
      covers_dpm: DPMbase
      name: str
      allow_multiple: Optional[bool] = True
      parent: Optional['TaxoDef'] = None
      children: Optional[list['Taxodef']] # default is empty list

  class TaxoLevel:
      """ Used to hold a taxonomy instance"""
      def __init__(self, taxo_type: DPMBase, taxo_def: TaxoDef, name:str):
          self.taxo_type = taxo_type
          self.taxo_def = taxo_def
          self.name = name
          self.dpm_model = None
      
  class TaxoLevelForDomain(TaxoLevel):
      def __init__(self, taxo_def: TaxoDef, name:str, description:Optional[str] = None):
          super().__init__(DPMBase.domain, taxo_def, name:str)
          self.dpm_model = ACTUAL_DB_CREATE_DOMAIN(name, description)
          
  class TaxoLevelForProject(TaxoLevel):
      def __init__(self, taxo_def: TaxoDef, name:str, domain:TaxoLevelForDomain description:Optional[str] = None):
      super().__init__(DPMBase.domain, taxo_def, name:str)
          self.dpm_model = ACTUAL_DB_CREATE_PROJECT(name, description)
      
  class TaxoLevelForTask(TaxoLevel):
      dmp_model: Project


  taxonomy = TaxoDef(
      covers_dpm = DPMBase.domain,
      name = "Software Project"
  )

  vision = taxonomy.children.append(
      TaxoDef(
          covers_dpm = DPMBase.project,
          name = "Vision",
          parent = taxonomy
          allow_multiple = False
      ]
  )
  deliverable = vision.children.append(
      TaxoDef(
          covers_dpm = DPMBase.project,
          name = "Deliverable",
          parent = vision
      ]
  )
  epic = vision.children.append(
      TaxoDef(
          covers_dpm = DPMBase.project,
          name = "Epic",
          parent = deliverable
      ]
  )
  story = vision.children.append(
      TaxoDef(
          covers_dpm = DPMBase.project,
          name = "Story",
          parent = epic
      ]
  )
  task = vision.children.append(
      TaxoDef(
          covers_dpm = DPMBase.task,
          name = "Task",
          parent = deliverable
      ]
  )


  d1 = TaxLevelForDomain(taxo_type=taxonomy, name="vBOSS")
  d1.add_sublevel(taxo_type=vision, name=

      
#+end_src
